### 数据结构和算法
**数据结构**：就是数据元素相互之间存在的一种或多种特定关机的集合。
###### 逻辑结构和物理结构
**逻辑结构**：数据对象中数据元素之间的相互关系  
    
    集合结构：一个集合中元素互不影响
    
    线性结构：数据元素之间1:1的关系
    
    树形结构：存在1:n的层次关系
    
    图形结构：n:n的关系
    
**物理结构**：数据的逻辑结构在计算机中的存储形式
存储形式有两种：顺序存储和链式存储

顺序存储：

    把数据元素存放在地址连续的存储单元里，其数据剑的逻辑关系和物理关系是一致的
链式存储：

    把数据元素存放在任意的存储单元里，该单元可以是连续的，也可以是不连续的。
    需要一个指针存放数据元素的地址，通过地址找到相关联的数据元素的位置。
    

#### 算法
五个基本特征：**输入**、**输出**、**有穷性**、**确定性**、**可行性**  
输入：* 0/多次  
输入：+ 1/多次  
有穷性：顾名思义不是无穷的。  
确定性：每个步骤都有具有确定的含义，不会出现二义性。  
可行性：每一步都是可行的。  
算法设计要求：

    正确性、可读性、健壮性、时间效率高，存储量低
**算法时间复杂度**
在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。  
记作：
    
    T(n)=O(f(n))；  
用大写O()来体现算法时间复杂度的记忆，称之为大O记法。  
一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。
一般存在  
```math
O(1),O(n),
    O(n^2).
```
分别为：常数阶，线性阶（循环），平方阶（嵌套循环）

##### 冒泡排序
乱序排列
```
        小到大排序
        public static int[] GetBubbelBytes2(int[] array)
        {
            int flag = 1;
            for (int i = 0; i < array.Length-1&&flag==1; i++)
            {
                flag = 0;
                for (int j = i+1; j < array.Length; j++)
                {
                    if (array[i]>array[j])
                    {
                        int temp = array[i];
                        array[i] = array[j];
                        array[j] = temp;
                        flag = 1;                    }
                }
            }
            return array;
        }
```
##### 插入排序
把一个元素插入到一个排列好的阿队列里
